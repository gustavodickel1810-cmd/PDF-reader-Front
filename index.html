<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional Multi-Language Document Reader</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.2/mammoth.browser.min.js"></script>
    <style>
        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #1a1a1a;
            --bg-tertiary: #2a2a2a;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --text-muted: #808080;
            --accent-primary: #4f46e5;
            --accent-secondary: #7c3aed;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
            --border: #3a3a3a;
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            min-height: 100vh;
            color: var(--text-primary);
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 24px;
        }

        .header {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 32px;
            text-align: center;
        }

        .header h1 {
            font-size: 3rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 16px;
            letter-spacing: -0.02em;
        }

        .header p {
            color: var(--text-secondary);
            font-size: 1.125rem;
            max-width: 600px;
            margin: 0 auto;
        }

        .language-tabs {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin: 32px 0;
            padding: 8px;
            background: var(--bg-tertiary);
            border-radius: 16px;
            border: 1px solid var(--border);
            max-width: 400px;
            margin: 32px auto;
        }

        .tab-button {
            flex: 1;
            background: transparent;
            color: var(--text-secondary);
            border: none;
            padding: 12px 24px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .tab-button.active {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 8px 25px rgba(79, 70, 229, 0.3);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .card {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 32px;
            margin-bottom: 24px;
        }

        .card h3 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 24px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .card-icon {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .file-input-container {
            position: relative;
        }

        .file-input {
            display: none;
        }

        .file-input-label {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 16px;
            padding: 48px;
            border: 2px dashed var(--border);
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: var(--bg-secondary);
            min-height: 140px;
            position: relative;
            overflow: hidden;
        }

        .file-input-label::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(79, 70, 229, 0.1), transparent);
            transition: left 0.5s;
        }

        .file-input-label:hover {
            border-color: var(--accent-primary);
            background: var(--bg-tertiary);
            transform: translateY(-2px);
        }

        .file-input-label:hover::before {
            left: 100%;
        }

        .upload-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }

        .voice-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }

        .voice-option {
            padding: 20px;
            border: 2px solid var(--border);
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: var(--bg-secondary);
            position: relative;
            overflow: hidden;
        }

        .voice-option::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(79, 70, 229, 0.1), transparent);
            transition: left 0.5s;
        }

        .voice-option:hover {
            border-color: var(--accent-primary);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .voice-option:hover::before {
            left: 100%;
        }

        .voice-option.selected {
            border-color: var(--accent-primary);
            background: linear-gradient(135deg, rgba(79, 70, 229, 0.1), rgba(124, 58, 237, 0.1));
            box-shadow: 0 8px 25px rgba(79, 70, 229, 0.2);
        }

        .voice-name {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
            font-size: 1.125rem;
        }

        .voice-details {
            color: var(--text-secondary);
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .voice-flag {
            width: 20px;
            height: 15px;
            border-radius: 3px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }

        .control-group {
            display: flex;
            gap: 16px;
            align-items: center;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }

        .control-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 200px;
        }

        .control-item label {
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: var(--bg-tertiary);
            outline: none;
            border: 1px solid var(--border);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.3);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            cursor: pointer;
            border: none;
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.3);
        }

        .btn {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(79, 70, 229, 0.4);
        }

        .btn:hover:not(:disabled)::before {
            left: 100%;
        }

        .btn:disabled {
            background: var(--bg-tertiary);
            color: var(--text-muted);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
        }

        .btn-warning {
            background: linear-gradient(135deg, var(--warning), #f97316);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--error), #dc2626);
        }

        .audio-player {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 24px;
            margin: 24px 0;
        }

        .player-controls {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 16px;
        }

        .play-pause-btn {
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border: none;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0; /* Hide any stray text/emoji */
            transition: all 0.3s ease;
        }

        /* Styling for the main play/pause button */
        .play-pause-btn.main-control {
            width: 56px;
            height: 56px;
        }

        /* Styling for the skip buttons */
        .play-pause-btn.skip-control {
            width: 40px;
            height: 40px;
        }

        .play-pause-btn svg {
            /* Common SVG styling */
            width: 24px; 
            height: 24px;
            stroke: white;
            fill: none;
            stroke-width: 2;
        }

        .play-pause-btn.skip-control svg {
            /* Smaller SVG size for skip buttons */
            width: 18px; 
            height: 18px;
        }

        .play-pause-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(79, 70, 229, 0.4);
        }

        .audio-progress {
            flex: 1;
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            border: 1px solid var(--border);
        }

        .audio-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            border-radius: 4px;
            width: 0%;
            transition: width 0.1s ease;
        }

        .time-display {
            font-size: 0.875rem;
            color: var(--text-secondary);
            min-width: 80px;
            font-family: 'JetBrains Mono', monospace;
        }

        .speed-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        .speed-btn {
            background: transparent;
            border: none;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-secondary);
            transition: all 0.2s ease;
            text-transform: uppercase;
        }

        .speed-btn.active {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: white;
        }

        .document-content {
            line-height: 1.8;
            font-size: 16px;
            color: var(--text-primary);
            max-height: 500px;
            overflow-y: auto;
            padding: 24px;
            border: 1px solid var(--border);
            border-radius: 16px;
            background: var(--bg-secondary);
        }

        .document-content::-webkit-scrollbar {
            width: 8px;
        }

        .document-content::-webkit-scrollbar-track {
            background: var(--bg-tertiary);
            border-radius: 4px;
        }

        .document-content::-webkit-scrollbar-thumb {
            background: var(--accent-primary);
            border-radius: 4px;
        }

        .chunk-highlight {
            background: linear-gradient(120deg, var(--accent-primary), var(--accent-secondary));
            padding: 2px 6px;
            border-radius: 6px;
            color: white;
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(79, 70, 229, 0.3);
        }

        .status {
            text-align: center;
            padding: 16px 24px;
            border-radius: 12px;
            margin: 16px 0;
            font-weight: 600;
            border: 1px solid;
        }

        .status.info {
            background: rgba(59, 130, 246, 0.1);
            color: #60a5fa;
            border-color: rgba(59, 130, 246, 0.3);
        }

        .status.error {
            background: rgba(239, 68, 68, 0.1);
            color: #f87171;
            border-color: rgba(239, 68, 68, 0.3);
        }

        .status.success {
            background: rgba(16, 185, 129, 0.1);
            color: #34d399;
            border-color: rgba(16, 185, 129, 0.3);
        }

        .cache-status {
            background: rgba(16, 185, 129, 0.1);
            border: 2px solid rgba(16, 185, 129, 0.3);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 24px;
            display: none;
        }

        .cache-content {
            display: flex;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
        }

        .cache-bar {
            width: 200px;
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
            margin-left: auto;
            border: 1px solid var(--border);
        }

        .cache-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success), #22c55e);
            width: 0%;
            transition: width 0.3s ease;
        }

        .server-status {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 16px;
            margin: 20px 0;
            text-align: center;
            display: none;
            font-weight: 600;
        }

        .server-status.online {
            border-color: rgba(16, 185, 129, 0.5);
            color: var(--success);
            display: block;
        }

        .server-status.offline {
            border-color: rgba(239, 68, 68, 0.5);
            color: var(--error);
            display: block;
        }

        .server-status.checking {
            border-color: rgba(245, 158, 11, 0.5);
            color: var(--warning);
            display: block;
        }

        @media (max-width: 768px) {
            .container {
                padding: 16px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .card {
                padding: 20px;
            }
            
            .control-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            .voice-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Smooth scrolling */
        html {
            scroll-behavior: smooth;
        }

        /* Selection color */
        ::selection {
            background: rgba(79, 70, 229, 0.3);
            color: var(--text-primary);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Document Reader Pro</h1>
            <p>Advanced text-to-speech with natural AI voices for English and Portuguese documents</p>
            
            <div id="serverStatus" class="server-status checking">
                Checking server connection...
            </div>

            <div id="corsWarning" class="server-status offline" style="display: none;">
                CORS Error: Please serve this file from a web server, not file://
                <br><small>Run: <code>python -m http.server 8080</code> or <code>npx http-server</code></small>
            </div>
            
            <div class="language-tabs">
                <button class="tab-button active" onclick="switchLanguage('english')">English</button>
                <button class="tab-button" onclick="switchLanguage('portuguese')">Portugu√™s</button>
            </div>
        </div>

        <div id="english-content" class="tab-content active">
            <div class="card">
                <h3><span class="card-icon">üìÑ</span>Upload Document</h3>
                <div class="file-input-container">
                    <input type="file" id="fileInputEn" class="file-input" accept=".pdf,.docx,.txt">
                    <label for="fileInputEn" class="file-input-label">
                        <div class="upload-icon">üìÑ</div>
                        <div style="font-weight: 600; font-size: 1.125rem;">Click to upload English document</div>
                        <div style="color: var(--text-secondary);">Supports PDF, DOCX, and TXT files</div>
                    </label>
                </div>
            </div>

            <div class="card">
                <h3><span class="card-icon">üé§</span>Choose Voice</h3>
                <div class="voice-grid" id="voiceGridEn">
                    </div>
            </div>

            <div class="card">
                <h3><span class="card-icon">‚öôÔ∏è</span>Reading Settings</h3>
                <div class="control-group">
                    <div class="control-item">
                        <label for="chunkSizeEn">Words per chunk: <span id="chunkDisplayEn">10</span></label>
                        <input type="range" id="chunkSizeEn" min="5" max="20" step="1" value="10">
                    </div>
                </div>
            </div>

            <div class="card">
                <h3><span class="card-icon">üéõÔ∏è</span>Controls</h3>
                
                <div class="cache-status" id="cacheStatusEn">
                    <div class="cache-content">
                        <div id="cacheIconEn">üì¶</div>
                        <div>
                            <strong>Audio Cache:</strong> 
                            <span id="cacheProgressEn">0/0 chunks cached</span>
                        </div>
                        <div class="cache-bar">
                            <div id="cacheBarFillEn" class="cache-bar-fill"></div>
                        </div>
                    </div>
                </div>
                
                <div class="audio-player" id="audioPlayerEn" style="display: none;">
                    <div class="player-controls">
                        <button class="play-pause-btn skip-control" id="skipBackBtnEn" title="Skip to Start (Click 2x for Previous Chunk)">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polygon points="19 20 9 12 19 4 19 20"></polygon>
                                <line x1="5" y1="19" x2="5" y2="5"></line>
                            </svg>
                        </button>
                        
                        <button class="play-pause-btn main-control" id="playPauseBtnEn">
                            <svg id="playIconEn" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polygon points="5 3 19 12 5 21 5 3"></polygon>
                            </svg>
                            <svg id="pauseIconEn" style="display: none;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="6" y="4" width="4" height="16"></rect>
                                <rect x="14" y="4" width="4" height="16"></rect>
                            </svg>
                        </button>
                        
                        <button class="play-pause-btn skip-control" id="skipAheadBtnEn" title="Skip to Next Chunk">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polygon points="5 4 15 12 5 20 5 4"></polygon>
                                <line x1="19" y1="5" x2="19" y2="19"></line>
                            </svg>
                        </button>

                        <div class="audio-progress" id="audioProgressEn">
                            <div class="audio-progress-fill" id="audioProgressFillEn"></div>
                        </div>
                        <div class="time-display" id="timeDisplayEn">0:00 / 0:00</div>
                    </div>
                    <div class="speed-controls" id="speedControlsEn">
                        <span style="color: var(--text-secondary); font-size: 0.75rem; font-weight: 600;">Speed:</span>
                        <button class="speed-btn" onclick="setSpeed('en', 0.75)">0.75x</button>
                        <button class="speed-btn active" onclick="setSpeed('en', 1.0)">1.0x</button>
                        <button class="speed-btn" onclick="setSpeed('en', 1.25)">1.25x</button>
                        <button class="speed-btn" onclick="setSpeed('en', 1.5)">1.5x</button>
                        <button class="speed-btn" onclick="setSpeed('en', 2.0)">2.0x</button>
                    </div>
                </div>

                <div class="control-group">
                    <button id="startReadingEn" class="btn" disabled>Start Reading</button>
                    <button id="stopReadingEn" class="btn btn-secondary" disabled>Stop</button>
                    <button id="testVoiceEn" class="btn btn-secondary" disabled>Test Voice</button>
                    <button onclick="window.documentReader.readers.en.clearCache()" class="btn btn-warning">Clear Cache</button>
                </div>
            </div>

            <div id="statusEn" class="status info" style="display: none;"></div>

            <div class="card">
                <h3><span class="card-icon">üìñ</span>Document Content</h3>
                <div id="documentContentEn" class="document-content">
                    <p style="text-align: center; color: var(--text-secondary); font-style: italic;">
                        Upload an English document to begin reading
                    </p>
                </div>
            </div>
        </div>

        <div id="portuguese-content" class="tab-content">
            <div class="card">
                <h3><span class="card-icon">üìÑ</span>Carregar Documento</h3>
                <div class="file-input-container">
                    <input type="file" id="fileInputPt" class="file-input" accept=".pdf,.docx,.txt">
                    <label for="fileInputPt" class="file-input-label">
                        <div class="upload-icon">üìÑ</div>
                        <div style="font-weight: 600; font-size: 1.125rem;">Clique para carregar documento em portugu√™s</div>
                        <div style="color: var(--text-secondary);">Suporta arquivos PDF, DOCX e TXT</div>
                    </label>
                </div>
            </div>

            <div class="card">
                <h3><span class="card-icon">üé§</span>Escolher Voz</h3>
                <div class="voice-grid" id="voiceGridPt">
                    </div>
            </div>

            <div class="card">
                <h3><span class="card-icon">‚öôÔ∏è</span>Configura√ß√µes de Leitura</h3>
                <div class="control-group">
                    <div class="control-item">
                        <label for="chunkSizePt">Palavras por bloco: <span id="chunkDisplayPt">10</span></label>
                        <input type="range" id="chunkSizePt" min="5" max="20" step="1" value="10">
                    </div>
                </div>
            </div>

            <div class="card">
                <h3><span class="card-icon">üéõÔ∏è</span>Controles</h3>
                
                <div class="cache-status" id="cacheStatusPt">
                    <div class="cache-content">
                        <div id="cacheIconPt">üì¶</div>
                        <div>
                            <strong>Cache de √Åudio:</strong> 
                            <span id="cacheProgressPt">0/0 blocos armazenados</span>
                        </div>
                        <div class="cache-bar">
                            <div id="cacheBarFillPt" class="cache-bar-fill"></div>
                        </div>
                    </div>
                </div>
                
                <div class="audio-player" id="audioPlayerPt" style="display: none;">
                    <div class="player-controls">
                        <button class="play-pause-btn skip-control" id="skipBackBtnPt" title="Voltar ao In√≠cio (Clique 2x para Bloco Anterior)">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polygon points="19 20 9 12 19 4 19 20"></polygon>
                                <line x1="5" y1="19" x2="5" y2="5"></line>
                            </svg>
                        </button>
                        
                        <button class="play-pause-btn main-control" id="playPauseBtnPt">
                            <svg id="playIconPt" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polygon points="5 3 19 12 5 21 5 3"></polygon>
                            </svg>
                            <svg id="pauseIconPt" style="display: none;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="6" y="4" width="4" height="16"></rect>
                                <rect x="14" y="4" width="4" height="16"></rect>
                            </svg>
                        </button>
                        
                        <button class="play-pause-btn skip-control" id="skipAheadBtnPt" title="Avan√ßar para o Pr√≥ximo Bloco">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polygon points="5 4 15 12 5 20 5 4"></polygon>
                                <line x1="19" y1="5" x2="19" y2="19"></line>
                            </svg>
                        </button>

                        <div class="audio-progress" id="audioProgressPt">
                            <div class="audio-progress-fill" id="audioProgressFillPt"></div>
                        </div>
                        <div class="time-display" id="timeDisplayPt">0:00 / 0:00</div>
                    </div>
                    <div class="speed-controls" id="speedControlsPt">
                        <span style="color: var(--text-secondary); font-size: 0.75rem; font-weight: 600;">Velocidade:</span>
                        <button class="speed-btn" onclick="setSpeed('pt', 0.75)">0.75x</button>
                        <button class="speed-btn active" onclick="setSpeed('pt', 1.0)">1.0x</button>
                        <button class="speed-btn" onclick="setSpeed('pt', 1.25)">1.25x</button>
                        <button class="speed-btn" onclick="setSpeed('pt', 1.5)">1.5x</button>
                        <button class="speed-btn" onclick="setSpeed('pt', 2.0)">2.0x</button>
                    </div>
                </div>

                <div class="control-group">
                    <button id="startReadingPt" class="btn" disabled>Iniciar Leitura</button>
                    <button id="stopReadingPt" class="btn btn-secondary" disabled>Parar</button>
                    <button id="testVoicePt" class="btn btn-secondary" disabled>Testar Voz</button>
                    <button onclick="window.documentReader.readers.pt.clearCache()" class="btn btn-warning">Limpar Cache</button>
                </div>
            </div>

            <div id="statusPt" class="status info" style="display: none;"></div>

            <div class="card">
                <h3><span class="card-icon">üìñ</span>Conte√∫do do Documento</h3>
                <div id="documentContentPt" class="document-content">
                    <p style="text-align: center; color: var(--text-secondary); font-style: italic;">
                        Carregue um documento em portugu√™s para come√ßar a leitura
                    </p>
                </div>
            </div>
        </div>
    </div>
    <script>
        // Global functions - defined first
        function detectFileProtocol() {
            if (window.location.protocol === 'file:') {
                const corsWarning = document.getElementById('corsWarning');
                const serverStatus = document.getElementById('serverStatus');
                if (corsWarning && serverStatus) {
                    corsWarning.style.display = 'block';
                    serverStatus.style.display = 'none';
                }
                return true;
            }
            return false;
        }

        async function checkServerStatus() {
            // Don't check server if running from file://
            if (detectFileProtocol()) return;

            const serverStatus = document.getElementById('serverStatus');
            if (!serverStatus) return;

            try {
                // Set checking status
                serverStatus.textContent = 'Checking server connection...';
                serverStatus.className = 'server-status checking';

                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout

                // NOTE: Using the hardcoded URL from the user's original file, assuming it's the backend.
                const response = await fetch('https://pdf-reader-back.onrender.com/api/health', { 
                    method: 'GET', 
                    signal: controller.signal 
                });
                
                clearTimeout(timeoutId);

                if (response.ok) {
                    const data = await response.json();
                    serverStatus.textContent = 'Backend server is running';
                    serverStatus.className = 'server-status online';
                    console.log('Server health check passed:', data);
                } else {
                    throw new Error(`Server responded with status: ${response.status}`);
                }
            } catch (error) {
                console.warn('Server health check failed:', error.message);
                if (error.name === 'AbortError') {
                    serverStatus.textContent = 'Server connection timeout - Please start: node server.js';
                } else {
                    serverStatus.textContent = 'Backend server offline - Please run: node server.js';
                }
                serverStatus.className = 'server-status offline';
            }
        }

        function switchLanguage(language) {
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');

            // Update content visibility
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(`${language}-content`).classList.add('active');

            // Update current language
            if (window.documentReader) {
                const langCode = language === 'english' ? 'en' : 'pt';
                window.documentReader.currentLanguage = langCode;
                // Ensure UI is updated if user switches tabs
                window.documentReader.readers[langCode].updateSpeedUI();
            }
        }

        function setSpeed(language, speed) {
            const reader = window.documentReader.readers[language];
            reader.playbackSpeed = speed; // Set the global playback speed for the reader
            
            // NEW: Save speed to localStorage for persistence
            localStorage.setItem(`readerSpeed_${language}`, speed);
            
            // Update active speed button and apply to current audio
            reader.updateSpeedUI(); 

            // Apply speed to current audio if playing (Immediate change)
            if (reader.currentAudio) {
                reader.currentAudio.playbackRate = speed;
            }
            // NOTE: The crucial part for *future* chunks is that playAudioBlob uses reader.playbackSpeed
        }

        class EnhancedDocumentReader {
            constructor() {
                this.readers = {
                    en: new LanguageReader('en'),
                    pt: new LanguageReader('pt')
                };
                this.currentLanguage = 'en';
                this.initializeElements();
                this.setupEventListeners();
                this.populateVoices();
                
                // Set initial speed UI after readers are initialized
                this.readers.en.updateSpeedUI();
                this.readers.pt.updateSpeedUI();
            }

            initializeElements() {
                // Initialize both language readers
                this.readers.en.initializeElements('En');
                this.readers.pt.initializeElements('Pt');
            }

            setupEventListeners() {
                this.readers.en.setupEventListeners('En');
                this.readers.pt.setupEventListeners('Pt');
            }

            populateVoices() {
                this.readers.en.populateVoices();
                this.readers.pt.populateVoices();
            }
        }

        class LanguageReader {
            constructor(language) {
                this.language = language;
                this.currentDocument = null;
                this.currentChunks = [];
                this.currentChunkIndex = 0;
                this.isPlaying = false;
                
                // --- VOICE UPDATE ---
                // Set default voice (updated to 'Joanna' for English)
                this.selectedVoice = language === 'en' ? 'Joanna' : 'Ricardo'; 
                // --- END VOICE UPDATE ---

                this.chunkSize = 10;
                this.currentAudio = null;
                this.audioBlobs = new Map(); // Cache downloaded audio

                // NEW: Initialize playback speed from localStorage or default to 1.0
                const storedSpeed = localStorage.getItem(`readerSpeed_${language}`);
                this.playbackSpeed = storedSpeed ? parseFloat(storedSpeed) : 1.0;
                
                this.preloadQueue = []; // Queue for preloading audio
                this.isPreloading = false;
                this.preloadedCount = 0;
                this.maxPreloadChunks = 15; // Preload up to 15 chunks (roughly 5 minutes)
                this.lastSkipBackClickTime = 0; // For double-click logic

                // --- VOICE UPDATE: CORRECT VOICE NAMES ---
                this.availableVoices = language === 'en' ? [
                    { name: 'Joanna', language: 'English (US)', gender: 'Female', langCode: 'en-US', flag: 'üá∫üá∏', apiName: 'Joanna' },
                    { name: 'Matthew', language: 'English (US)', gender: 'Male', langCode: 'en-US', flag: 'üá∫üá∏', apiName: 'Matthew' },
                    { name: 'Amy', language: 'English (UK)', gender: 'Female', langCode: 'en-GB', flag: 'üá¨üáß', apiName: 'Amy' },
                    { name: 'George', language: 'English (UK)', gender: 'Male', langCode: 'en-GB', flag: 'üá¨üáß', apiName: 'George' },
                ] : [
                    { name: 'Camila', language: 'Portugu√™s (Brasil)', gender: 'Feminino', langCode: 'pt-BR', flag: 'üáßüá∑', apiName: 'Camila' },
                    { name: 'Ricardo', language: 'Portugu√™s (Brasil)', gender: 'Masculino', langCode: 'pt-BR', flag: 'üáßüá∑', apiName: 'Ricardo' },
                    { name: 'Ines', language: 'Portugu√™s (Portugal)', gender: 'Feminino', langCode: 'pt-PT', flag: 'üáµüáπ', apiName: 'Ines' },
                    { name: 'Cristiano', language: 'Portugu√™s (Portugal)', gender: 'Masculino', langCode: 'pt-PT', flag: 'üáµüáπ', apiName: 'Cristiano' },
                ];
                // --- END VOICE UPDATE ---
            }

            initializeElements(suffix) {
                this.fileInput = document.getElementById(`fileInput${suffix}`);
                this.voiceGrid = document.getElementById(`voiceGrid${suffix}`);
                this.chunkSizeInput = document.getElementById(`chunkSize${suffix}`);
                this.chunkDisplay = document.getElementById(`chunkDisplay${suffix}`);
                this.startReadingBtn = document.getElementById(`startReading${suffix}`);
                this.stopReadingBtn = document.getElementById(`stopReading${suffix}`);
                this.testVoiceBtn = document.getElementById(`testVoice${suffix}`);
                this.documentContent = document.getElementById(`documentContent${suffix}`);
                this.status = document.getElementById(`status${suffix}`);
                this.audioPlayer = document.getElementById(`audioPlayer${suffix}`);
                this.playPauseBtn = document.getElementById(`playPauseBtn${suffix}`);
                this.playIcon = document.getElementById(`playIcon${suffix}`);
                this.pauseIcon = document.getElementById(`pauseIcon${suffix}`);
                this.skipBackBtn = document.getElementById(`skipBackBtn${suffix}`);
                this.skipAheadBtn = document.getElementById(`skipAheadBtn${suffix}`);
                this.audioProgress = document.getElementById(`audioProgress${suffix}`);
                this.audioProgressFill = document.getElementById(`audioProgressFill${suffix}`);
                this.timeDisplay = document.getElementById(`timeDisplay${suffix}`);
                this.speedControls = document.getElementById(`speedControls${suffix}`);
                this.cacheStatus = document.getElementById(`cacheStatus${suffix}`);
                this.cacheProgress = document.getElementById(`cacheProgress${suffix}`);
                this.cacheBarFill = document.getElementById(`cacheBarFill${suffix}`);

                // Set initial chunk display value
                this.chunkDisplay.textContent = this.chunkSizeInput.value;
            }

            setupEventListeners(suffix) {
                // File Input
                this.fileInput.addEventListener('change', (e) => this.handleFileSelect(e.target.files[0]));

                // Chunk Size Slider
                this.chunkSizeInput.addEventListener('input', (e) => {
                    this.chunkSize = parseInt(e.target.value);
                    this.chunkDisplay.textContent = this.chunkSize;
                });

                // Control Buttons
                this.startReadingBtn.addEventListener('click', () => this.startReading());
                this.stopReadingBtn.addEventListener('click', () => this.stopReading());
                this.testVoiceBtn.addEventListener('click', () => this.testVoice());
                this.playPauseBtn.addEventListener('click', () => this.togglePlayback());
                this.skipAheadBtn.addEventListener('click', () => this.skipChunk(1));
                this.skipBackBtn.addEventListener('click', () => this.handleSkipBack());

                // Audio Progress Bar
                this.audioProgress.addEventListener('click', (e) => this.seekAudio(e));
                
                // Highlight on scroll
                this.documentContent.addEventListener('scroll', () => this.syncHighlightToScroll());
            }

            handleSkipBack() {
                const now = Date.now();
                const doubleClickThreshold = 400; // milliseconds

                if (now - this.lastSkipBackClickTime < doubleClickThreshold) {
                    // Double click: Skip to previous chunk
                    this.skipChunk(-1);
                    this.lastSkipBackClickTime = 0; // Reset for next sequence
                } else {
                    // Single click: Skip to start of current chunk
                    if (this.currentAudio) {
                        this.currentAudio.currentTime = 0;
                    }
                }
                this.lastSkipBackClickTime = now;
            }
            
            updateSpeedUI() {
                // Remove active class from all speed buttons
                this.speedControls.querySelectorAll('.speed-btn').forEach(btn => btn.classList.remove('active'));
                
                // Find and set active class on the button matching the current speed
                this.speedControls.querySelectorAll('.speed-btn').forEach(btn => {
                    // Extract speed from the onclick attribute string
                    const match = btn.getAttribute('onclick').match(/setSpeed\('.+', (\d\.?\d*)?\)/);
                    if (match && parseFloat(match[1]) === this.playbackSpeed) {
                        btn.classList.add('active');
                    }
                });
            }

            populateVoices() {
                this.voiceGrid.innerHTML = ''; // Clear existing voices

                this.availableVoices.forEach(voice => {
                    const voiceOption = document.createElement('div');
                    voiceOption.className = 'voice-option';
                    voiceOption.id = `voice-${voice.apiName}`;
                    voiceOption.dataset.apiName = voice.apiName;

                    if (voice.apiName === this.selectedVoice) {
                        voiceOption.classList.add('selected');
                        this.testVoiceBtn.disabled = false;
                    }

                    voiceOption.innerHTML = `
                        <div class="voice-name">${voice.name}</div>
                        <div class="voice-details">
                            <span class="voice-flag">${voice.flag}</span>
                            <span>${voice.language} - ${voice.gender}</span>
                        </div>
                    `;

                    voiceOption.addEventListener('click', () => this.selectVoice(voice.apiName));
                    this.voiceGrid.appendChild(voiceOption);
                });
            }

            selectVoice(apiName) {
                this.selectedVoice = apiName;
                this.voiceGrid.querySelectorAll('.voice-option').forEach(opt => {
                    opt.classList.remove('selected');
                });
                document.getElementById(`voice-${apiName}`).classList.add('selected');
                this.testVoiceBtn.disabled = false;
            }
            
            async handleFileSelect(file) {
                if (!file) return;

                this.showStatus(`Loading file: ${file.name}...`, 'info');
                this.documentContent.innerHTML = '';
                this.currentDocument = null;
                this.currentChunks = [];
                this.currentChunkIndex = 0;
                this.clearCache(false);
                this.stopReading();
                this.audioPlayer.style.display = 'none';
                this.startReadingBtn.disabled = true;

                let content = '';
                try {
                    const arrayBuffer = await file.arrayBuffer();

                    if (file.name.toLowerCase().endsWith('.pdf')) {
                        content = await this.readPdf(arrayBuffer);
                    } else if (file.name.toLowerCase().endsWith('.docx')) {
                        content = await this.readDocx(arrayBuffer);
                    } else if (file.name.toLowerCase().endsWith('.txt')) {
                        content = new TextDecoder().decode(arrayBuffer);
                    } else {
                        throw new Error("Unsupported file type.");
                    }
                    
                    this.currentDocument = content;
                    this.currentChunks = this.chunkText(content, this.chunkSize);
                    this.renderDocumentContent(this.currentChunks);
                    this.startReadingBtn.disabled = false;
                    this.showStatus(`Successfully loaded "${file.name}" with ${this.currentChunks.length} chunks.`, 'success');
                } catch (error) {
                    console.error('File reading error:', error);
                    this.showStatus(`Error reading file: ${error.message}`, 'error');
                }
            }

            async readPdf(arrayBuffer) {
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                let text = '';
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    text += textContent.items.map(item => item.str).join(' ') + '\n\n';
                }
                return text.replace(/\s+/g, ' ').trim();
            }

            async readDocx(arrayBuffer) {
                const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
                return result.value.replace(/\s+/g, ' ').trim();
            }

            chunkText(text, wordsPerChunk) {
                const sentences = text.match(/[^.!?]+[.!?]|\S+/g) || [];
                const chunks = [];
                let currentChunk = [];

                for (const sentence of sentences) {
                    const words = sentence.trim().split(/\s+/);
                    if (currentChunk.length + words.length <= wordsPerChunk) {
                        currentChunk.push(sentence.trim());
                    } else {
                        if (currentChunk.length > 0) {
                            chunks.push(currentChunk.join(' '));
                        }
                        currentChunk = [sentence.trim()];
                    }
                }

                if (currentChunk.length > 0) {
                    chunks.push(currentChunk.join(' '));
                }

                // Fallback for huge blocks of text without punctuation
                if (chunks.length === 0 && text.length > 0) {
                    const words = text.split(/\s+/);
                    for (let i = 0; i < words.length; i += wordsPerChunk) {
                        chunks.push(words.slice(i, i + wordsPerChunk).join(' '));
                    }
                }

                return chunks.filter(c => c.length > 0);
            }

            renderDocumentContent(chunks) {
                this.documentContent.innerHTML = '';
                chunks.forEach((chunk, index) => {
                    const span = document.createElement('span');
                    span.id = `chunk-${this.language}-${index}`;
                    span.textContent = chunk + ' ';
                    this.documentContent.appendChild(span);
                });
            }

            highlightChunk(index) {
                this.documentContent.querySelectorAll('span').forEach(span => {
                    span.classList.remove('chunk-highlight');
                });

                const currentSpan = document.getElementById(`chunk-${this.language}-${index}`);
                if (currentSpan) {
                    currentSpan.classList.add('chunk-highlight');
                    this.scrollToChunk(currentSpan);
                }
            }
            
            scrollToChunk(element) {
                const container = this.documentContent;
                const containerRect = container.getBoundingClientRect();
                const elementRect = element.getBoundingClientRect();
            
                // Calculate position to center the element, accounting for container scroll
                const scrollPosition = element.offsetTop - container.offsetTop - (containerRect.height / 2) + (elementRect.height / 2);
            
                // Use smooth scroll
                container.scrollTo({
                    top: scrollPosition,
                    behavior: 'smooth'
                });
            }

            // Sync the highlight to the chunk currently visible on screen center
            syncHighlightToScroll() {
                if (this.isPlaying) return; // Don't interfere with automatic highlighting

                const container = this.documentContent;
                const containerHeight = container.clientHeight;
                const scrollCenter = container.scrollTop + containerHeight / 2;
                
                for (let i = 0; i < this.currentChunks.length; i++) {
                    const chunkElement = document.getElementById(`chunk-${this.language}-${i}`);
                    if (!chunkElement) continue;

                    const elementTop = chunkElement.offsetTop;
                    const elementBottom = elementTop + chunkElement.offsetHeight;

                    // Check if the center of the scroll container is within the bounds of the chunk element
                    if (scrollCenter >= elementTop && scrollCenter < elementBottom) {
                        this.highlightChunk(i);
                        this.currentChunkIndex = i;
                        break;
                    }
                }
            }

            async startReading() {
                if (!this.currentChunks.length) {
                    this.showStatus('Please upload a document first.', 'warning');
                    return;
                }

                this.isPlaying = true;
                this.currentChunkIndex = 0;
                this.audioPlayer.style.display = 'block';
                this.stopReadingBtn.disabled = false;
                this.startReadingBtn.disabled = true;
                this.updatePlayPauseIcon(true);
                
                // Start preloading immediately
                this.preloadAudio();
                
                // Start playing
                await this.readChunksSequentially();
            }

            stopReading() {
                this.isPlaying = false;
                if (this.currentAudio) {
                    this.currentAudio.pause();
                    this.currentAudio = null;
                }
                this.updatePlayPauseIcon(false);
                this.stopReadingBtn.disabled = true;
                if (this.currentChunks.length > 0) {
                    this.startReadingBtn.disabled = false;
                }
                this.cacheStatus.style.display = 'none';
                this.updateTimeDisplay(0, 0);
            }

            togglePlayback() {
                if (!this.currentChunks.length) return;

                if (this.isPlaying) {
                    this.isPlaying = false;
                    if (this.currentAudio) this.currentAudio.pause();
                    this.updatePlayPauseIcon(false);
                } else {
                    this.isPlaying = true;
                    this.audioPlayer.style.display = 'block';
                    this.stopReadingBtn.disabled = false;
                    this.startReadingBtn.disabled = true;
                    this.updatePlayPauseIcon(true);

                    if (this.currentAudio && this.currentAudio.paused) {
                        // Resume current audio
                        this.currentAudio.play().catch(e => {
                            console.error("Resume play failed:", e);
                            this.readChunksSequentially(); // Fallback to starting sequence
                        });
                    } else {
                        // Start reading from the current index
                        this.readChunksSequentially();
                    }
                }
            }

            skipChunk(direction) {
                if (!this.currentChunks.length) return;
                
                this.currentChunkIndex += direction;
                
                // Bound the index
                if (this.currentChunkIndex < 0) this.currentChunkIndex = 0;
                if (this.currentChunkIndex >= this.currentChunks.length) {
                    this.currentChunkIndex = this.currentChunks.length - 1;
                    this.stopReading();
                    this.showStatus('Finished reading the document.', 'success');
                    return;
                }

                // Stop current audio and immediately start reading from the new index
                if (this.currentAudio) {
                    this.currentAudio.pause();
                    this.currentAudio = null;
                }
                this.readChunksSequentially();
            }

            async readChunksSequentially() {
                while (this.isPlaying && this.currentChunkIndex < this.currentChunks.length) {
                    const chunk = this.currentChunks[this.currentChunkIndex];
                    this.highlightChunk(this.currentChunkIndex);
                    
                    try {
                        await this.playChunk(chunk, this.currentChunkIndex);
                        
                        if (this.isPlaying) {
                            this.currentChunkIndex++;
                        }
                    } catch (error) {
                        if (this.isPlaying) {
                            console.error(`Error playing chunk ${this.currentChunkIndex}:`, error);
                            this.showStatus(`Failed to play chunk ${this.currentChunkIndex+1}. Skipping...`, 'error');
                            // Skip the chunk on error
                            this.currentChunkIndex++; 
                        }
                    }
                }

                if (this.currentChunkIndex >= this.currentChunks.length) {
                    this.stopReading();
                    this.showStatus('Finished reading the document.', 'success');
                }
            }

            async playChunk(text, index) {
                if (!this.isPlaying) return;

                let audioUrl;
                let isCached = false;

                // 1. Try to get from in-memory cache
                if (this.audioBlobs.has(index)) {
                    const blob = this.audioBlobs.get(index);
                    audioUrl = URL.createObjectURL(blob);
                    isCached = true;
                } else {
                    // 2. Fetch from TTS API via proxy
                    this.showStatus(`Generating audio for chunk ${index + 1}/${this.currentChunks.length}...`, 'info');
                    const ttsResponse = await this.getTtsUrl(text, this.selectedVoice);
                    audioUrl = ttsResponse.audioUrl;
                    
                    if (ttsResponse.cached === 1) {
                         isCached = true;
                    }

                    // 3. Download the audio file via proxy for CORS bypass and to create a Blob for in-memory caching
                    const blob = await this.downloadAudioAsBlob(audioUrl);
                    this.audioBlobs.set(index, blob);
                    audioUrl = URL.createObjectURL(blob);
                    
                    this.preloadedCount++;
                    this.updateCacheStatus();
                }
                
                if (!isCached) {
                    this.showStatus(`Playing chunk ${index + 1}/${this.currentChunks.length} (Generated by ${this.selectedVoice}).`, 'info');
                } else {
                    this.showStatus(`Playing chunk ${index + 1}/${this.currentChunks.length} (Cached).`, 'success');
                }
                
                return new Promise((resolve, reject) => {
                    this.currentAudio = new Audio(audioUrl);
                    this.currentAudio.playbackRate = this.playbackSpeed; // Apply saved speed
                    this.currentAudio.onerror = (e) => {
                        console.error('Audio playback error:', e);
                        reject(new Error('Audio playback failed.'));
                    };

                    this.currentAudio.onended = () => {
                        URL.revokeObjectURL(audioUrl); // Clean up the Blob URL
                        resolve();
                    };

                    this.currentAudio.ontimeupdate = () => {
                        this.updateTimeDisplay(this.currentAudio.currentTime, this.currentAudio.duration);
                    };

                    // Start playing
                    this.currentAudio.play().catch(e => {
                        // This catch block handles "The play() request was interrupted by a call to pause()."
                        // or "The play() failed because the user didn't interact with the document first."
                        if (this.isPlaying) {
                            // If we're still supposed to be playing, it's a real error or
                            // an interruption that means we should resolve to move to the next chunk.
                            console.warn("Audio play promise rejected, but continuing:", e);
                            resolve(); 
                        } else {
                            // If we stopped playing, we should not resolve/reject the promise, just stop.
                            // The outer loop's `this.isPlaying` check will handle loop termination.
                        }
                    });
                    
                    // Preload next chunks while playing
                    this.preloadAudio(); 
                });
            }
            
            async getTtsUrl(text, voiceName) {
                // Ensure text is under a reasonable limit to prevent API abuse
                if (text.length > 1000) {
                    text = text.substring(0, 1000); 
                    console.warn("TTS text truncated to 1000 characters.");
                }

                // NOTE: Using the hardcoded URL from the user's original file, assuming it's the backend.
                const backendUrl = 'https://pdf-reader-back.onrender.com/api/tts';
                
                const response = await fetch(backendUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ text, voiceName }),
                });

                if (!response.ok) {
                    // THIS IS WHERE THE 500 ERROR IS CAUGHT
                    throw new Error(`TTS API failed with status ${response.status}. Check backend logs.`);
                }

                const data = await response.json();
                if (data.error) {
                    throw new Error(`TTS API returned error: ${data.details}`);
                }
                return data;
            }

            async downloadAudioAsBlob(audioUrl) {
                 // NOTE: Using the hardcoded URL from the user's original file, assuming it's the backend.
                const backendUrl = 'https://pdf-reader-back.onrender.com/api/download-audio';
                
                const response = await fetch(backendUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ audioUrl }),
                });

                if (!response.ok) {
                    throw new Error(`Audio download proxy failed with status ${response.status}.`);
                }

                // Return the response body as a Blob
                return await response.blob();
            }

            async preloadAudio() {
                if (this.isPreloading || !this.currentChunks.length) return;

                this.isPreloading = true;
                this.cacheStatus.style.display = 'block';
                this.updateCacheStatus();

                for (let i = this.currentChunkIndex; i < this.currentChunks.length; i++) {
                    if (this.audioBlobs.has(i) || i >= this.currentChunkIndex + this.maxPreloadChunks) {
                        continue; // Already cached or reached preload limit
                    }
                    
                    const chunk = this.currentChunks[i];
                    try {
                         this.showStatus(`Preloading chunk ${i + 1}/${this.currentChunks.length}...`, 'info');
                         const ttsResponse = await this.getTtsUrl(chunk, this.selectedVoice);
                         const blob = await this.downloadAudioAsBlob(ttsResponse.audioUrl);
                         this.audioBlobs.set(i, blob);
                         this.preloadedCount++;
                         this.updateCacheStatus();
                         
                         // Stop preloading if user stopped playback
                         if (!this.isPlaying) {
                            break;
                         }

                    } catch (error) {
                        console.error(`Preload failed for chunk ${i+1}:`, error.message);
                        // Stop preloading on error to avoid rate limits
                        break; 
                    }
                }
                
                this.showStatus('Preloading complete or paused.', 'success');
                this.isPreloading = false;
            }
            
            clearCache(showSuccess = true) {
                this.audioBlobs.forEach(blob => URL.revokeObjectURL(URL.createObjectURL(blob))); // Revoke old URLs
                this.audioBlobs.clear();
                this.preloadedCount = 0;
                this.isPreloading = false;
                this.updateCacheStatus();
                this.cacheStatus.style.display = 'none';
                if (showSuccess) {
                    this.showStatus('Audio cache cleared successfully.', 'warning');
                }
            }
            
            updateCacheStatus() {
                const total = this.currentChunks.length;
                const cached = this.audioBlobs.size;
                
                this.cacheProgress.textContent = `${cached}/${total} chunks cached`;
                
                const percentage = total > 0 ? (cached / total) * 100 : 0;
                this.cacheBarFill.style.width = `${percentage}%`;
                
                if (cached > 0) {
                    this.cacheStatus.style.display = 'block';
                } else {
                    this.cacheStatus.style.display = 'none';
                }
            }

            updateTimeDisplay(currentTime, duration) {
                const formatTime = (seconds) => {
                    const min = Math.floor(seconds / 60);
                    const sec = Math.floor(seconds % 60);
                    return `${min}:${sec < 10 ? '0' : ''}${sec}`;
                };

                const currentFormatted = formatTime(currentTime || 0);
                const durationFormatted = formatTime(duration || 0);

                this.timeDisplay.textContent = `${currentFormatted} / ${durationFormatted}`;
                
                if (this.currentAudio && this.currentAudio.duration) {
                     const percent = (currentTime / duration) * 100;
                     this.audioProgressFill.style.width = `${percent}%`;
                }
            }

            seekAudio(e) {
                if (!this.currentAudio) return;

                const rect = this.audioProgress.getBoundingClientRect();
                const offsetX = e.clientX - rect.left;
                const percent = offsetX / rect.width;
                const seekTime = this.currentAudio.duration * percent;

                this.currentAudio.currentTime = seekTime;
            }

            async testVoice() {
                const testText = this.language === 'en' ? 
                    "This is a voice test for the selected English voice." : 
                    "Este √© um teste de voz para a voz portuguesa selecionada.";
                
                this.showStatus(`Testing voice: ${this.selectedVoice}...`, 'info');
                this.testVoiceBtn.disabled = true;

                try {
                    // 1. Get TTS URL
                    const ttsResponse = await this.getTtsUrl(testText, this.selectedVoice);
                    
                    // 2. Download audio via proxy
                    const blob = await this.downloadAudioAsBlob(ttsResponse.audioUrl);
                    const audioUrl = URL.createObjectURL(blob);

                    // 3. Play the audio
                    const testAudio = new Audio(audioUrl);
                    testAudio.playbackRate = this.playbackSpeed;
                    
                    testAudio.oncanplaythrough = () => {
                         testAudio.play().catch(e => {
                            this.showStatus('Error playing test audio. User must interact with the document first.', 'error');
                            this.testVoiceBtn.disabled = false;
                        });
                    };

                    testAudio.onended = () => {
                        URL.revokeObjectURL(audioUrl);
                        this.showStatus('Voice test complete.', 'success');
                        this.testVoiceBtn.disabled = false;
                    };

                } catch (error) {
                    console.error('Voice test failed:', error);
                    this.showStatus(`Voice test failed: ${error.message}`, 'error');
                    this.testVoiceBtn.disabled = false;
                }
            }

            updatePlayPauseIcon(playing) {
                if (this.playIcon && this.pauseIcon) {
                    if (playing) {
                        this.playIcon.style.display = 'none';
                        this.pauseIcon.style.display = 'block';
                    } else {
                        this.playIcon.style.display = 'block';
                        this.pauseIcon.style.display = 'none';
                    }
                }
            }

            showStatus(message, type) {
                this.status.textContent = message;
                this.status.className = `status ${type}`;
                this.status.style.display = 'block';
                
                if (type === 'success' || type === 'info') {
                    setTimeout(() => {
                        this.status.style.display = 'none';
                    }, 3000);
                }
            }
        }

        // Initialize the application when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            // Configure PDF.js worker
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
            
            // Check server status on page load
            checkServerStatus();
            
            // Check server status every 10 seconds
            setInterval(checkServerStatus, 10000);
            
            // Initialize the document reader
            window.documentReader = new EnhancedDocumentReader();
            
            console.log('Enhanced Multi-Language Document Reader initialized successfully!');
        });
    </script>
</body>
</html>